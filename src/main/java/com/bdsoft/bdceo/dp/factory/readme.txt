
关于工厂相关设计模式的总结：
工厂模式主要是为创建对象提供了接口

参考：
http://blog.csdn.net/maosong00/article/details/10182237
http://www.apkbus.com/blog-85308-54616.html
http://lh-kevin.iteye.com/blog/1981574

主要涉及：简单工厂-SimpleFactory，抽象工厂-AbstractFActory 和 工厂方法：Creator

	三个模式的出现目的是为了将对象的创建过程进行统一封装和管理，实现解耦
	
	简单工厂：参见 com.bdsoft.bdceo.dp.factory.simple.*.java 
		优点：
		　　工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.
		        通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。
		        而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利，有利于整个软件体系结构的优化。
		缺点：
		　　由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；
		        它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。
		　　当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．
		        这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；
		　　这些缺点在工厂方法模式中得到了一定的克服。
		使用场景
		　　工厂类负责创建的对象比较少；
		　　客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；
		　　由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。
		

	抽象工厂：参见 com.bdsoft.bdceo.dp.factory.nongchang.*.java
			  com.bdsoft.bdceo.dp.factory.nvwa.*.java
		构造出来的对象属于同类型的，“产品族”的概念，同时出现了产品树和产品族时使用该模式
		每个工厂只负责同产品族的产品构造
		多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   
		一个抽象工厂类，可以派生出多个具体工厂类。   
		每个具体工厂类可以创建多个具体产品类的实例。
	
	
	工厂方法：参见 com.bdsoft.bdceo.dp.factory.method.*.java
		构造出来的对象可以是多个类型的
		针对每一种产品，提供一个工厂，通过不同的工厂实例，创建不同类型的产品实例
		在同一产品类型中，支持添加任意数量的产品
		一个抽象产品类，可以派生出多个具体产品类。   
		一个抽象工厂类，可以派生出多个具体工厂类。   
		每个具体工厂类只能创建一个具体产品类的实例。
		
		